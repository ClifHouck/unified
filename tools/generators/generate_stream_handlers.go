package main

import (
	"os"
	"reflect"
	"strings"
	"text/template"

	log "github.com/sirupsen/logrus"

	"github.com/ClifHouck/unified/types"
)

type StreamHandlerArguments struct {
	PackageName         string
	StreamType          string
	EventType           string
	EventTypeFirstLower string
	AllEventTypes       []interface{}
	Filename            string
}

const TOP_OF_FILE_COMMENT = `// (!) DO NOT EDIT (!) Generated by generate_stream_handlers
`

const STREAM_HANDLER_PACKAGE = "package {{.PackageName}}\n\n"

const IMPORTS = `import (
	"context"
	"encoding/json"
	"sync"

	log "github.com/sirupsen/logrus"

	"github.com/ClifHouck/unified/types"
)
`

const STREAM_HANDLER_STRUCT_BEGIN = `
type {{.StreamType}}StreamHandler struct {
	ctx    context.Context
	stream <-chan *types.{{.StreamType}}
`

const STREAM_HANDLER_STRUCT_EVENT_TYPE_MEMBERS = `
	{{.EventTypeFirstLower}}Handler func(string, *types.{{.EventType}})
	{{.EventTypeFirstLower}}Mutex   sync.Mutex
`

const STREAM_HANDLER_STRUCT_END = `} // {{.StreamType}}StreamHandler
`

const NEW_STREAM_HANDLER_OBJECT_FUNCTION = `
func New{{.StreamType}}StreamHandler(ctx context.Context,
	stream <-chan *types.{{.StreamType}}) *{{.StreamType}}StreamHandler {
	handler := &{{.StreamType}}StreamHandler{
		ctx:    ctx,
		stream: stream,
	}

	// Should this be here, or should clients of this class call it
	// explicitly?
	go handler.processStream()

	return handler
}
`

const PROCESS_STREAM_METHOD_BEGIN = `
func (esh *{{.StreamType}}StreamHandler) processStream() {
	log.Info("Waiting for events...")
	for {
		select {
		case streamEvent := <-esh.stream:
			if streamEvent == nil {
				log.Warn("Got nil event. Bailing out!")
				return
			}

			var item types.{{.StreamType}}Item
			err := json.Unmarshal(streamEvent.RawItem, &item)
			if err != nil {
				log.Error("Couldn't parse RawItem!")
				log.Error(err.Error())
			}

			log.WithFields(log.Fields{
				"ID":           item.ID,
				"event.type":   streamEvent.ItemType,
				"message.type": streamEvent.Type,
			}).Info("Received {{.StreamType}}")

			switch event := streamEvent.Item.(type) {
`

const PROCESS_STREAM_CASE = `case *types.{{.EventType}}:
				go esh.invoke{{.EventType}}Handler(streamEvent.Type, event)
`

const PROCESS_STREAM_METHOD_END = `
			default:
				log.Errorf("Unknown type encountered: '%s'", streamEvent.ItemType)
			}

		case <-esh.ctx.Done():
			log.Warn("Got context.Done!")
			return
		}
	}
}
`

const SET_EVENT_HANDLER_METHOD = `
func (esh *{{.StreamType}}StreamHandler) Set{{.EventType}}Handler(handler func(string, *types.{{.EventType}})) {
	esh.{{.EventTypeFirstLower}}Mutex.Lock()
	defer esh.{{.EventTypeFirstLower}}Mutex.Unlock()

	esh.{{.EventTypeFirstLower}}Handler = handler
}
`

const INVOKE_EVENT_HANDLER_METHOD = `
func (esh *{{.StreamType}}StreamHandler) invoke{{.EventType}}Handler(eventType string, event *types.{{.EventType}}) {
	esh.{{.EventTypeFirstLower}}Mutex.Lock()
	defer esh.{{.EventTypeFirstLower}}Mutex.Unlock()

	if esh.{{.EventTypeFirstLower}}Handler != nil {
		go esh.{{.EventTypeFirstLower}}Handler(eventType, event)
	}
}
`

var ALL_TEMPLATE_DEFINITIONS = map[string]string{
	"topOfFileComment":                    TOP_OF_FILE_COMMENT,
	"streamHandlerPackage":                STREAM_HANDLER_PACKAGE,
	"imports":                             IMPORTS,
	"streamHandlerStructBegin":            STREAM_HANDLER_STRUCT_BEGIN,
	"streamHandlerStructEventTypeMembers": STREAM_HANDLER_STRUCT_EVENT_TYPE_MEMBERS,
	"streamHandlerStructEnd":              STREAM_HANDLER_STRUCT_END,
	"newStreamHandlerObjectFunction":      NEW_STREAM_HANDLER_OBJECT_FUNCTION,
	"processStreamMethodBegin":            PROCESS_STREAM_METHOD_BEGIN,
	"processStreamCase":                   PROCESS_STREAM_CASE,
	"processStreamMethodEnd":              PROCESS_STREAM_METHOD_END,
	"setEventHandlerMethod":               SET_EVENT_HANDLER_METHOD,
	"invokeEventHandlerMethod":            INVOKE_EVENT_HANDLER_METHOD,
}

func renderStreamHandlerToFile(args *StreamHandlerArguments) error {
	outFile, err := os.OpenFile(args.Filename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		return err
	}

	templates := map[string]*template.Template{}
	for k, v := range ALL_TEMPLATE_DEFINITIONS {
		templates[k] = template.Must(template.New(k).Parse(v))
	}

	eventTypeNames := []string{}
	for _, eventObj := range args.AllEventTypes {
		eventTypeNames = append(eventTypeNames, reflect.TypeOf(eventObj).Name())
	}

	for _, templateName := range []string{
		"topOfFileComment",
		"streamHandlerPackage",
		"imports",
		"streamHandlerStructBegin",
	} {
		err = templates[templateName].Execute(outFile, args)
		if err != nil {
			return err
		}
	}

	for _, eventTypeName := range eventTypeNames {
		args.EventType = eventTypeName
		args.EventTypeFirstLower = strings.ToLower(eventTypeName[:1]) + eventTypeName[1:]
		err = templates["streamHandlerStructEventTypeMembers"].Execute(outFile, args)
		if err != nil {
			return err
		}
	}

	for _, templateName := range []string{
		"streamHandlerStructEnd",
		"newStreamHandlerObjectFunction",
		"processStreamMethodBegin",
	} {
		err = templates[templateName].Execute(outFile, args)
		if err != nil {
			return err
		}
	}

	for _, eventTypeName := range eventTypeNames {
		args.EventType = eventTypeName
		args.EventTypeFirstLower = strings.ToLower(eventTypeName[:1]) + eventTypeName[1:]
		err = templates["processStreamCase"].Execute(outFile, args)
		if err != nil {
			return err
		}
	}

	err = templates["processStreamMethodEnd"].Execute(outFile, args)
	if err != nil {
		return err
	}

	for _, eventTypeName := range eventTypeNames {
		args.EventType = eventTypeName
		args.EventTypeFirstLower = strings.ToLower(eventTypeName[:1]) + eventTypeName[1:]
		err = templates["setEventHandlerMethod"].Execute(outFile, args)
		if err != nil {
			return err
		}

		err = templates["invokeEventHandlerMethod"].Execute(outFile, args)
		if err != nil {
			return err
		}
	}

	log.WithFields(log.Fields{
		"filename":   args.Filename,
		"streamType": args.StreamType,
	}).Info("Stream Handler successfully rendered to file.")
	return nil
}

func main() {
	streamArgs := []*StreamHandlerArguments{
		&StreamHandlerArguments{
			Filename:      "client/protect_device_update_stream_handler.go",
			PackageName:   "client",
			StreamType:    "ProtectDeviceEvent",
			AllEventTypes: types.ALL_PROTECT_DEVICE_EVENTS,
		},
		&StreamHandlerArguments{
			Filename:      "client/protect_event_stream_handler.go",
			PackageName:   "client",
			StreamType:    "ProtectEvent",
			AllEventTypes: types.ALL_PROTECT_EVENTS,
		},
	}

	for _, streamArg := range streamArgs {
		err := renderStreamHandlerToFile(streamArg)
		if err != nil {
			log.Error(err.Error())
			return
		}
	}
}
