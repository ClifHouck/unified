package client

import (
	"context"
	"encoding/json"
	"sync"

	log "github.com/sirupsen/logrus"

	"github.com/ClifHouck/unified/types"
)

// (!) DO NOT EDIT (!) Generated by generate_stream_handlers

type ProtectEventStreamHandler struct {
	ctx    context.Context
	stream <-chan *types.ProtectEvent

	ringEventHandler func(string, *types.RingEvent)
	ringEventMutex   sync.Mutex

	sensorExtremeValuesEventHandler func(string, *types.SensorExtremeValuesEvent)
	sensorExtremeValuesEventMutex   sync.Mutex

	sensorWaterLeakEventHandler func(string, *types.SensorWaterLeakEvent)
	sensorWaterLeakEventMutex   sync.Mutex

	sensorTamperEventHandler func(string, *types.SensorTamperEvent)
	sensorTamperEventMutex   sync.Mutex

	sensorBatteryLowEventHandler func(string, *types.SensorBatteryLowEvent)
	sensorBatteryLowEventMutex   sync.Mutex

	sensorAlarmEventHandler func(string, *types.SensorAlarmEvent)
	sensorAlarmEventMutex   sync.Mutex

	sensorOpenedEventHandler func(string, *types.SensorOpenedEvent)
	sensorOpenedEventMutex   sync.Mutex

	sensorClosedEventHandler func(string, *types.SensorClosedEvent)
	sensorClosedEventMutex   sync.Mutex

	lightMotionEventHandler func(string, *types.LightMotionEvent)
	lightMotionEventMutex   sync.Mutex

	cameraMotionEventHandler func(string, *types.CameraMotionEvent)
	cameraMotionEventMutex   sync.Mutex

	cameraSmartDetectAudioEventHandler func(string, *types.CameraSmartDetectAudioEvent)
	cameraSmartDetectAudioEventMutex   sync.Mutex

	cameraSmartDetectZoneEventHandler func(string, *types.CameraSmartDetectZoneEvent)
	cameraSmartDetectZoneEventMutex   sync.Mutex

	cameraSmartDetectLineEventHandler func(string, *types.CameraSmartDetectLineEvent)
	cameraSmartDetectLineEventMutex   sync.Mutex

	cameraSmartDetectLoiterEventHandler func(string, *types.CameraSmartDetectLoiterEvent)
	cameraSmartDetectLoiterEventMutex   sync.Mutex
} // ProtectEventStreamHandler

func NewProtectEventStreamHandler(ctx context.Context,
	stream <-chan *types.ProtectEvent) *ProtectEventStreamHandler {
	handler := &ProtectEventStreamHandler{
		ctx:    ctx,
		stream: stream,
	}

	// Should this be here, or should clients of this class call it
	// explicitly?
	go handler.processStream()

	return handler
}

func (esh *ProtectEventStreamHandler) processStream() {
	log.Info("Waiting for events...")
	for {
		select {
		case streamEvent := <-esh.stream:
			if streamEvent == nil {
				log.Warn("Got nil event. Bailing out!")
				return
			}

			var item types.ProtectEventItem
			err := json.Unmarshal(streamEvent.RawItem, &item)
			if err != nil {
				log.Error("Couldn't parse RawItem!")
				log.Error(err.Error())
			}

			log.WithFields(log.Fields{
				"ID":           item.ID,
				"event.type":   streamEvent.ItemType,
				"message.type": streamEvent.Type,
			}).Info("Received ProtectEvent")

			switch event := streamEvent.Item.(type) {
			case *types.RingEvent:
				go esh.invokeRingEventHandler(streamEvent.Type, event)
			case *types.SensorExtremeValuesEvent:
				go esh.invokeSensorExtremeValuesEventHandler(streamEvent.Type, event)
			case *types.SensorWaterLeakEvent:
				go esh.invokeSensorWaterLeakEventHandler(streamEvent.Type, event)
			case *types.SensorTamperEvent:
				go esh.invokeSensorTamperEventHandler(streamEvent.Type, event)
			case *types.SensorBatteryLowEvent:
				go esh.invokeSensorBatteryLowEventHandler(streamEvent.Type, event)
			case *types.SensorAlarmEvent:
				go esh.invokeSensorAlarmEventHandler(streamEvent.Type, event)
			case *types.SensorOpenedEvent:
				go esh.invokeSensorOpenedEventHandler(streamEvent.Type, event)
			case *types.SensorClosedEvent:
				go esh.invokeSensorClosedEventHandler(streamEvent.Type, event)
			case *types.LightMotionEvent:
				go esh.invokeLightMotionEventHandler(streamEvent.Type, event)
			case *types.CameraMotionEvent:
				go esh.invokeCameraMotionEventHandler(streamEvent.Type, event)
			case *types.CameraSmartDetectAudioEvent:
				go esh.invokeCameraSmartDetectAudioEventHandler(streamEvent.Type, event)
			case *types.CameraSmartDetectZoneEvent:
				go esh.invokeCameraSmartDetectZoneEventHandler(streamEvent.Type, event)
			case *types.CameraSmartDetectLineEvent:
				go esh.invokeCameraSmartDetectLineEventHandler(streamEvent.Type, event)
			case *types.CameraSmartDetectLoiterEvent:
				go esh.invokeCameraSmartDetectLoiterEventHandler(streamEvent.Type, event)

			default:
				log.Errorf("Unknown type encountered: '%s'", streamEvent.ItemType)
			}

		case <-esh.ctx.Done():
			log.Warn("Got context.Done!")
			return
		}
	}
}

func (esh *ProtectEventStreamHandler) SetRingEventHandler(handler func(string, *types.RingEvent)) {
	esh.ringEventMutex.Lock()
	defer esh.ringEventMutex.Unlock()

	esh.ringEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeRingEventHandler(eventType string, event *types.RingEvent) {
	esh.ringEventMutex.Lock()
	defer esh.ringEventMutex.Unlock()

	if esh.ringEventHandler != nil {
		go esh.ringEventHandler(eventType, event)
	}
}

func (esh *ProtectEventStreamHandler) SetSensorExtremeValuesEventHandler(handler func(string, *types.SensorExtremeValuesEvent)) {
	esh.sensorExtremeValuesEventMutex.Lock()
	defer esh.sensorExtremeValuesEventMutex.Unlock()

	esh.sensorExtremeValuesEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeSensorExtremeValuesEventHandler(eventType string, event *types.SensorExtremeValuesEvent) {
	esh.sensorExtremeValuesEventMutex.Lock()
	defer esh.sensorExtremeValuesEventMutex.Unlock()

	if esh.sensorExtremeValuesEventHandler != nil {
		go esh.sensorExtremeValuesEventHandler(eventType, event)
	}
}

func (esh *ProtectEventStreamHandler) SetSensorWaterLeakEventHandler(handler func(string, *types.SensorWaterLeakEvent)) {
	esh.sensorWaterLeakEventMutex.Lock()
	defer esh.sensorWaterLeakEventMutex.Unlock()

	esh.sensorWaterLeakEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeSensorWaterLeakEventHandler(eventType string, event *types.SensorWaterLeakEvent) {
	esh.sensorWaterLeakEventMutex.Lock()
	defer esh.sensorWaterLeakEventMutex.Unlock()

	if esh.sensorWaterLeakEventHandler != nil {
		go esh.sensorWaterLeakEventHandler(eventType, event)
	}
}

func (esh *ProtectEventStreamHandler) SetSensorTamperEventHandler(handler func(string, *types.SensorTamperEvent)) {
	esh.sensorTamperEventMutex.Lock()
	defer esh.sensorTamperEventMutex.Unlock()

	esh.sensorTamperEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeSensorTamperEventHandler(eventType string, event *types.SensorTamperEvent) {
	esh.sensorTamperEventMutex.Lock()
	defer esh.sensorTamperEventMutex.Unlock()

	if esh.sensorTamperEventHandler != nil {
		go esh.sensorTamperEventHandler(eventType, event)
	}
}

func (esh *ProtectEventStreamHandler) SetSensorBatteryLowEventHandler(handler func(string, *types.SensorBatteryLowEvent)) {
	esh.sensorBatteryLowEventMutex.Lock()
	defer esh.sensorBatteryLowEventMutex.Unlock()

	esh.sensorBatteryLowEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeSensorBatteryLowEventHandler(eventType string, event *types.SensorBatteryLowEvent) {
	esh.sensorBatteryLowEventMutex.Lock()
	defer esh.sensorBatteryLowEventMutex.Unlock()

	if esh.sensorBatteryLowEventHandler != nil {
		go esh.sensorBatteryLowEventHandler(eventType, event)
	}
}

func (esh *ProtectEventStreamHandler) SetSensorAlarmEventHandler(handler func(string, *types.SensorAlarmEvent)) {
	esh.sensorAlarmEventMutex.Lock()
	defer esh.sensorAlarmEventMutex.Unlock()

	esh.sensorAlarmEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeSensorAlarmEventHandler(eventType string, event *types.SensorAlarmEvent) {
	esh.sensorAlarmEventMutex.Lock()
	defer esh.sensorAlarmEventMutex.Unlock()

	if esh.sensorAlarmEventHandler != nil {
		go esh.sensorAlarmEventHandler(eventType, event)
	}
}

func (esh *ProtectEventStreamHandler) SetSensorOpenedEventHandler(handler func(string, *types.SensorOpenedEvent)) {
	esh.sensorOpenedEventMutex.Lock()
	defer esh.sensorOpenedEventMutex.Unlock()

	esh.sensorOpenedEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeSensorOpenedEventHandler(eventType string, event *types.SensorOpenedEvent) {
	esh.sensorOpenedEventMutex.Lock()
	defer esh.sensorOpenedEventMutex.Unlock()

	if esh.sensorOpenedEventHandler != nil {
		go esh.sensorOpenedEventHandler(eventType, event)
	}
}

func (esh *ProtectEventStreamHandler) SetSensorClosedEventHandler(handler func(string, *types.SensorClosedEvent)) {
	esh.sensorClosedEventMutex.Lock()
	defer esh.sensorClosedEventMutex.Unlock()

	esh.sensorClosedEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeSensorClosedEventHandler(eventType string, event *types.SensorClosedEvent) {
	esh.sensorClosedEventMutex.Lock()
	defer esh.sensorClosedEventMutex.Unlock()

	if esh.sensorClosedEventHandler != nil {
		go esh.sensorClosedEventHandler(eventType, event)
	}
}

func (esh *ProtectEventStreamHandler) SetLightMotionEventHandler(handler func(string, *types.LightMotionEvent)) {
	esh.lightMotionEventMutex.Lock()
	defer esh.lightMotionEventMutex.Unlock()

	esh.lightMotionEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeLightMotionEventHandler(eventType string, event *types.LightMotionEvent) {
	esh.lightMotionEventMutex.Lock()
	defer esh.lightMotionEventMutex.Unlock()

	if esh.lightMotionEventHandler != nil {
		go esh.lightMotionEventHandler(eventType, event)
	}
}

func (esh *ProtectEventStreamHandler) SetCameraMotionEventHandler(handler func(string, *types.CameraMotionEvent)) {
	esh.cameraMotionEventMutex.Lock()
	defer esh.cameraMotionEventMutex.Unlock()

	esh.cameraMotionEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeCameraMotionEventHandler(eventType string, event *types.CameraMotionEvent) {
	esh.cameraMotionEventMutex.Lock()
	defer esh.cameraMotionEventMutex.Unlock()

	if esh.cameraMotionEventHandler != nil {
		go esh.cameraMotionEventHandler(eventType, event)
	}
}

func (esh *ProtectEventStreamHandler) SetCameraSmartDetectAudioEventHandler(handler func(string, *types.CameraSmartDetectAudioEvent)) {
	esh.cameraSmartDetectAudioEventMutex.Lock()
	defer esh.cameraSmartDetectAudioEventMutex.Unlock()

	esh.cameraSmartDetectAudioEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeCameraSmartDetectAudioEventHandler(eventType string, event *types.CameraSmartDetectAudioEvent) {
	esh.cameraSmartDetectAudioEventMutex.Lock()
	defer esh.cameraSmartDetectAudioEventMutex.Unlock()

	if esh.cameraSmartDetectAudioEventHandler != nil {
		go esh.cameraSmartDetectAudioEventHandler(eventType, event)
	}
}

func (esh *ProtectEventStreamHandler) SetCameraSmartDetectZoneEventHandler(handler func(string, *types.CameraSmartDetectZoneEvent)) {
	esh.cameraSmartDetectZoneEventMutex.Lock()
	defer esh.cameraSmartDetectZoneEventMutex.Unlock()

	esh.cameraSmartDetectZoneEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeCameraSmartDetectZoneEventHandler(eventType string, event *types.CameraSmartDetectZoneEvent) {
	esh.cameraSmartDetectZoneEventMutex.Lock()
	defer esh.cameraSmartDetectZoneEventMutex.Unlock()

	if esh.cameraSmartDetectZoneEventHandler != nil {
		go esh.cameraSmartDetectZoneEventHandler(eventType, event)
	}
}

func (esh *ProtectEventStreamHandler) SetCameraSmartDetectLineEventHandler(handler func(string, *types.CameraSmartDetectLineEvent)) {
	esh.cameraSmartDetectLineEventMutex.Lock()
	defer esh.cameraSmartDetectLineEventMutex.Unlock()

	esh.cameraSmartDetectLineEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeCameraSmartDetectLineEventHandler(eventType string, event *types.CameraSmartDetectLineEvent) {
	esh.cameraSmartDetectLineEventMutex.Lock()
	defer esh.cameraSmartDetectLineEventMutex.Unlock()

	if esh.cameraSmartDetectLineEventHandler != nil {
		go esh.cameraSmartDetectLineEventHandler(eventType, event)
	}
}

func (esh *ProtectEventStreamHandler) SetCameraSmartDetectLoiterEventHandler(handler func(string, *types.CameraSmartDetectLoiterEvent)) {
	esh.cameraSmartDetectLoiterEventMutex.Lock()
	defer esh.cameraSmartDetectLoiterEventMutex.Unlock()

	esh.cameraSmartDetectLoiterEventHandler = handler
}

func (esh *ProtectEventStreamHandler) invokeCameraSmartDetectLoiterEventHandler(eventType string, event *types.CameraSmartDetectLoiterEvent) {
	esh.cameraSmartDetectLoiterEventMutex.Lock()
	defer esh.cameraSmartDetectLoiterEventMutex.Unlock()

	if esh.cameraSmartDetectLoiterEventHandler != nil {
		go esh.cameraSmartDetectLoiterEventHandler(eventType, event)
	}
}
