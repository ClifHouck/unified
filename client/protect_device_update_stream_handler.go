// (!) DO NOT EDIT (!) Generated by generate_stream_handlers
package client

import (
	"context"
	"encoding/json"
	"sync"

	log "github.com/sirupsen/logrus"

	"github.com/ClifHouck/unified/types"
)

type ProtectDeviceEventStreamHandler struct {
	ctx    context.Context
	stream <-chan *types.ProtectDeviceEvent

	protectAddCameraEventHandler func(string, *types.ProtectAddCameraEvent)
	protectAddCameraEventMutex   sync.Mutex
} // ProtectDeviceEventStreamHandler

func NewProtectDeviceEventStreamHandler(ctx context.Context,
	stream <-chan *types.ProtectDeviceEvent) *ProtectDeviceEventStreamHandler {
	handler := &ProtectDeviceEventStreamHandler{
		ctx:    ctx,
		stream: stream,
	}

	// Should this be here, or should clients of this class call it
	// explicitly?
	go handler.processStream()

	return handler
}

func (esh *ProtectDeviceEventStreamHandler) processStream() {
	log.Info("Waiting for events...")
	for {
		select {
		case streamEvent := <-esh.stream:
			if streamEvent == nil {
				log.Warn("Got nil event. Bailing out!")
				return
			}

			var item types.ProtectDeviceEventItem
			err := json.Unmarshal(streamEvent.RawItem, &item)
			if err != nil {
				log.Error("Couldn't parse RawItem!")
				log.Error(err.Error())
			}

			log.WithFields(log.Fields{
				"ID":           item.ID,
				"event.type":   streamEvent.ItemType,
				"message.type": streamEvent.Type,
			}).Info("Received ProtectDeviceEvent")

			switch event := streamEvent.Item.(type) {

			case *types.ProtectAddCameraEvent:
				go esh.invokeProtectAddCameraEventHandler(streamEvent.Type, event)

			default:
				log.Errorf("Unknown type encountered: '%s'", streamEvent.ItemType)
			}

		case <-esh.ctx.Done():
			log.Warn("Got context.Done!")
			return
		}
	}
}

func (esh *ProtectDeviceEventStreamHandler) SetProtectAddCameraEventHandler(handler func(string, *types.ProtectAddCameraEvent)) {
	esh.protectAddCameraEventMutex.Lock()
	defer esh.protectAddCameraEventMutex.Unlock()

	esh.protectAddCameraEventHandler = handler
}

func (esh *ProtectDeviceEventStreamHandler) invokeProtectAddCameraEventHandler(eventType string, event *types.ProtectAddCameraEvent) {
	esh.protectAddCameraEventMutex.Lock()
	defer esh.protectAddCameraEventMutex.Unlock()

	if esh.protectAddCameraEventHandler != nil {
		go esh.protectAddCameraEventHandler(eventType, event)
	}
}
