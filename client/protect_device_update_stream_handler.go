// (!) DO NOT EDIT (!) Generated by generate_stream_handlers
package client
import "context"
import "encoding/json"
import "sync"

import log "github.com/sirupsen/logrus"

import "github.com/ClifHouck/unified/types"

type ProtectDeviceEventStreamHandler struct {
	ctx    context.Context
	stream <-chan *ProtectDeviceEventMessage

	protectAddCameraEventHandler func(string, *types.ProtectAddCameraEvent)
	protectAddCameraEventMutex   sync.Mutex

} // ProtectDeviceEventStreamHandler

func NewProtectDeviceEventStreamHandler(ctx context.Context,
	stream <-chan *ProtectDeviceEventMessage) *ProtectDeviceEventStreamHandler {
	handler := &ProtectDeviceEventStreamHandler{
		ctx:    ctx,
		stream: stream,
	}

	// Should this be here, or should clients of this class call it
	// explicitly?
	go handler.processStream()

	return handler
}

func (esh *ProtectDeviceEventStreamHandler) processStream() {
	log.Info("Waiting for events...")
	for {
		select {
		case message := <-esh.stream:
			if message == nil {
				log.Warn("Got nil message. Bailing out!")
				return
			}

			var item types.ProtectDeviceEventItem
			err := json.Unmarshal(message.Event.RawItem, &item)
			if err != nil {
				log.Error("Couldn't parse RawItem!")
				log.Error(err.Error())
			}

			log.WithFields(log.Fields{
				"ID":           item.ID,
				"event.type":   message.Event.ItemType,
				"message.type": message.Event.Type,
			}).Info("Received ProtectDeviceEvent")

			switch event := message.Event.Item.(type) {

			case *types.ProtectAddCameraEvent:
				go esh.invokeProtectAddCameraEventHandler(message.Event.Type, event)

			default:
				log.Errorf("Unknown type encountered: '%s'", message.Event.ItemType)
			}

			if message.Error != nil {
				log.Error(message.Error.Error())
				return
			}

		case <-esh.ctx.Done():
			log.Warn("Got context.Done!")
			return
		}
	}
}

func (esh *ProtectDeviceEventStreamHandler) SetProtectAddCameraEventHandler(handler func(string, *types.ProtectAddCameraEvent)) {
	esh.protectAddCameraEventMutex.Lock()
	defer esh.protectAddCameraEventMutex.Unlock()

	esh.protectAddCameraEventHandler = handler
}

func (esh *ProtectDeviceEventStreamHandler) invokeProtectAddCameraEventHandler(eventType string, event *types.ProtectAddCameraEvent) {
	esh.protectAddCameraEventMutex.Lock()
	defer esh.protectAddCameraEventMutex.Unlock()

	if esh.protectAddCameraEventHandler != nil {
		go esh.protectAddCameraEventHandler(eventType, event)
	}
}
